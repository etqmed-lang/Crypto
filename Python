import requests
import time
import datetime
import json
import csv

# -----------------------------------------------------------
# CONFIGURATION
# -----------------------------------------------------------
GITHUB_API = "https://api.github.com/repos/"
DEX_SCREENER_API = "https://api.dexscreener.com/latest/dex/tokens/"
COIN_GECKO = "https://api.coingecko.com/api/v3/coins/"
SMART_MONEY_API = "https://api.llama.fi/moneyflows/"

ETHERSCAN_API_KEY = "YOUR_ETHERSCAN_API_KEY"
ETHERSCAN_BASE = "https://api.etherscan.io/api"
SOLSCAN_BASE = "https://public-api.solscan.io"

TELEGRAM_BOT_TOKEN = "8587519408:AAHeWsi306g53W1LT3bjIxfcRKEhd1QW7bg"
TELEGRAM_CHAT_ID = 6241439814  # ÿ∂ÿπ User ID ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ ŸáŸÜÿß

RUN_INTERVAL = 60 * 30  # ŸÉŸÑ 30 ÿØŸÇŸäŸÇÿ©
LOG_CSV = "crypto_signals_log.csv"

TOKENS = [
    {"symbol": "SOL", "github": "solana-labs/solana", "contract": "So11111111111111111111111111111111111111112", "coingecko_id": "solana", "network": "solana"},
    {"symbol": "ETH", "github": "ethereum/go-ethereum", "contract": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", "coingecko_id": "weth", "network": "ethereum"},
    {"symbol": "APT", "github": "aptos-labs/aptos-core", "contract": "0x1::aptos_coin::AptosCoin", "coingecko_id": "aptos", "network": "aptos"},
    {"symbol": "SUI", "github": "MystenLabs/sui", "contract": "0x2::sui::SUI", "coingecko_id": "sui", "network": "sui"}
]

# -----------------------------------------------------------
# UTILS
# -----------------------------------------------------------
def safe_get_json(url, params=None, headers=None):
    try:
        r = requests.get(url, params=params, headers=headers, timeout=15)
        return r.json() if r.status_code == 200 else {}
    except:
        return {}

# -----------------------------------------------------------
# GITHUB
# -----------------------------------------------------------
def get_github_activity(repo):
    commits = safe_get_json(f"{GITHUB_API}{repo}/commits")
    issues = safe_get_json(f"{GITHUB_API}{repo}/issues")
    commit_count = len(commits) if isinstance(commits, list) else 0
    issue_count = len(issues) if isinstance(issues, list) else 0
    return {"commits": commit_count, "issues": issue_count, "score": 1 if commit_count > 8 else 0}

# -----------------------------------------------------------
# PRICE TREND
# -----------------------------------------------------------
def get_price_trend(coingecko_id):
    try:
        data = safe_get_json(f"{COIN_GECKO}{coingecko_id}")
        md = data.get("market_data", {})
        price_24h = md.get("price_change_percentage_24h", 0)
        price_7d = md.get("price_change_percentage_7d", 0)
        price_30d = md.get("price_change_percentage_30d", 0)
        score = 1 if (price_7d + price_30d)/2 > 0 else 0
        return {"24h": price_24h, "7d": price_7d, "30d": price_30d, "score": score}
    except:
        return {"score":0}

# -----------------------------------------------------------
# DEX VOLUME
# -----------------------------------------------------------
def get_dex_volume(token_address):
    try:
        data = safe_get_json(f"{DEX_SCREENER_API}{token_address}")
        volume = data.get("volume", 0) or data.get("pair", {}).get("volume", 0)
        score = 1 if volume and volume > 5_000_000 else 0
        return {"volume": volume, "score": score}
    except:
        return {"score":0}

# -----------------------------------------------------------
# SMART MONEY
# -----------------------------------------------------------
def get_smart_money(symbol):
    try:
        data = safe_get_json(f"{SMART_MONEY_API}{symbol.lower()}")
        inflow = data.get("inflow", 0)
        outflow = data.get("outflow", 0)
        score = 1 if inflow > outflow and inflow > 0 else 0
        return {"inflow": inflow, "outflow": outflow, "score": score}
    except:
        return {"score":0}

# -----------------------------------------------------------
# ONCHAIN METRICS
# -----------------------------------------------------------
def get_onchain_metrics(token):
    try:
        network = token.get("network")
        if network=="ethereum":
            params={'module':'account','action':'tokentx','contractaddress':token.get('contract'),'apikey':ETHERSCAN_API_KEY}
            data = safe_get_json(ETHERSCAN_BASE, params=params)
            tx_count = len(data.get('result',[])) if isinstance(data.get('result'),list) else 0
            score = 1 if tx_count>100 else 0
            return {"tx_count":tx_count,"score":score}
        elif network=="solana":
            url=f"{SOLSCAN_BASE}/token/meta?tokenAddress={token.get('contract')}"
            data=safe_get_json(url)
            tx_count = data.get('txCount',0)
            score = 1 if tx_count>100 else 0
            return {"tx_count":tx_count,"score":score}
        else: return {"score":0}
    except: return {"score":0}

# -----------------------------------------------------------
# TELEGRAM
# -----------------------------------------------------------
def telegram_notify(message):
    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID: return
    url=f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    payload={"chat_id":TELEGRAM_CHAT_ID,"text":message}
    try: requests.post(url,json=payload,timeout=10)
    except: pass

# -----------------------------------------------------------
# ANALYZE TOKEN
# -----------------------------------------------------------
def analyze_token(token):
    symbol = token["symbol"]
    github=get_github_activity(token["github"])
    price=get_price_trend(token["coingecko_id"])
    volume=get_dex_volume(token["contract"])
    whales=get_smart_money(symbol)
    onchain=get_onchain_metrics(token)

    score = github["score"] + price["score"] + volume["score"] + whales["score"] + onchain["score"]

    if score>=4: signal="STRONG BUY üî•üí∞"
    elif score>=3: signal="BUY üìà"
    else: signal="WAIT ‚è≥"

    timestamp = datetime.datetime.utcnow().isoformat()

    result={"timestamp":timestamp,"symbol":symbol,"score":score,"signal":signal,
            "components":{"github":github,"price":price,"dex_volume":volume,"smart_money":whales,"onchain":onchain}}

    log_to_csv(result)

    # Send detailed, readable message to Telegram
    msg=f"""
‚è∞ {timestamp}
üíé {symbol} Signal: {signal} (Score {score}/5)

üìå Components:
- GitHub: {github['commits']} commits, {github['issues']} issues
- Price: 24h {price['24h']}%, 7d {price['7d']}%, 30d {price['30d']}%
- DEX Volume: {volume['volume']}
- Smart Money: inflow {whales['inflow']}, outflow {whales['outflow']}
- On-chain tx: {onchain.get('tx_count',0)}
"""
    telegram_notify(msg)
    return result

# -----------------------------------------------------------
# LOGGING
# -----------------------------------------------------------
def log_to_csv(record):
    header=["timestamp","symbol","score","signal","github_commits","price_7d","price_30d","dex_volume","smart_inflow","onchain_tx"]
    row=[
        record.get('timestamp'),record.get('symbol'),record.get('score'),record.get('signal'),
        record['components']['github'].get('commits'),
        record['components']['price'].get('7d'),
        record['components']['price'].get('30d'),
        record['components']['dex_volume'].get('volume'),
        record['components']['smart_money'].get('inflow'),
        record['components']['onchain'].get('tx_count')
    ]
    try:
        write_header=False
        try: open(LOG_CSV,'r').close()
        except: write_header=True
        with open(LOG_CSV,'a',newline='') as f:
            writer=csv.writer(f)
            if write_header: writer.writerow(header)
            writer.writerow(row)
    except: pass

# -----------------------------------------------------------
# MAIN LOOP
# -----------------------------------------------------------
def run_cycle():
    for token in TOKENS:
        analyze_token(token)

if __name__=="__main__":
    print("Crypto Analysis Bot running...")
    try:
        while True:
            start=time.time()
            run_cycle()
            elapsed=time.time()-start
            sleep_time=max(10,RUN_INTERVAL-elapsed)
            print(f"Cycle finished at {datetime.datetime.utcnow().isoformat()} - sleeping {sleep_time}s")
            time.sleep(sleep_time)
    except KeyboardInterrupt:
        print("Stopped by user")
